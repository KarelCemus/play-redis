# ===================
# Redis cache configuration
# ===================
play.cache.redis: {

  # list of named caches available in the application
  #
  # for more details see https://www.playframework.com/documentation/2.6.x/ScalaCache#Accessing-different-caches
  #
  instance {

    # definition of the default cache,
    # its name is defined in 'play.cache.defaultCache'
    #
    # when there should be more caches, defined them all under the 'instance' key.
    #
    # for backward compatibility, the 'host', 'port', etc.
    # can be defined directly under 'play.cache.redis' key.
    # However, in such a case, it overrides the configuration of the default
    # cache and is reported as a warning because this configuration
    # is considered deprecated since 2.0.0
    #
    play {

      ##########################
      # Standalone mode
      ##########################

      # redis server: host
      host:       localhost
      # redis server: port
      port:       6379
      # redis server: database number
      database:   1
      # when authentication is required, define the password. The argument is optional
      password:   null

      ##########################
      # Cluster mode
      ##########################

      # list of nodes in a cluster either [] or null. Intentional use:
      #
      # cluster:  [
      #   # nodes are defined as a sequence of objects:
      #   # required string, defining a host the node is running on
      #   host:        localhost
      #   # required integer, defining a port the node is running on
      #   port:        6379
      #   # optional integer, defines a database to connect to
      #   database:    null
      #   # optional string, defines a password to use
      #   password:    null
      # ]
      #
      # To enable the cluster, set 'source' variable to 'cluster'
      #
      # Note: When cluster is set, the 'host', 'port',
      # and 'database' properties does not apply.
      #
      cluster:    null

      ##########################
      # Connection string mode
      ##########################

      # When the application is running in PaaS, it is
      # often required to configure the redis from the connection
      # string in the environmental variable. Play's configuration
      # resolves environmental variables through ${VARIABLE}, e.g.,
      # to run this library on Heroku, set 'connection-string'
      # variable to either '${REDIS_URL}' or '${REDISCLOUD_URL}'
      # depending on your PaaS configuration.
      #
      # The connection string can be also written statically thought
      # it is intended for the use with environmental variables.
      #
      # Note: To consider a 'connection-string' variable, set 'source'
      # to 'connection-string'.
      #
      connection-string:    null
    }
  }

  # configuration source. This library supports multiple types of
  # redis configuration provideres as well as it supports both
  # standalone instances and clusters. To simplify the configuration
  # and make it more explicit, 'source' property determines the intended
  # type of the instance. By default, each instance is considered
  # statically configured standalone redis server. However, supported values
  # are:
  #  - 'standalone' mode indicates a use of 'host', 'port', 'password'
  #      and 'database' variables
  #  - 'cluster' mode indicates use of 'cluster' variable defining nodes
  #  - 'connection-string' mode is usually used with PaaS as setup by the
  #      environment. It consideres 'connection-string' property.
  #  - 'custom' indicates that the user supplies his own RedisInstance configuration
  #
  # Default value is 'standalone'
  #
  # note: this is global definition, can be locally overriden for each
  # cache instance. To do so, redefine this property
  # under 'play.cache.redis.instance.instance-name.this-property'.
  #
  source: standalone

  # synchronization timeout applies only with synchronous API. It does not
  # apply with asynchronous API and you are free to ignore it. This value
  # is used with `Await.result`.
  #
  # note: this is global definition, can be locally overriden for each
  # cache instance. To do so, redefine this property
  # under 'play.cache.redis.instance.instance-name.this-property'.
  #
  timeout: 1s

  # akka dispatcher
  #
  # note: this is global definition, can be locally overriden for each
  # cache instance. To do so, redefine this property
  # under 'play.cache.redis.instance.instance-name.this-property'.
  #
  dispatcher: akka.actor.default-dispatcher

  # The intention of cache is usually to optimize the application behavior,
  # not to provide any business logic, i.e., it makes sense the cache could
  # be removed without any visible change except for possible performance loss.
  #
  # In consequence, we think that failed cache requests should not break the
  # application flow by emitting the exception, it should be logged and ignored.
  # However, not always this is desired behavior. To resolve this ambiguity,
  # we provide `RecoveryPolicy` trait implementing the behavior to be executed
  # when the cache request  fails. By default, we provide two implementations:
  #
  # 'log-and-fail':       Logs the error at firts and then emits RedisException
  #
  # 'log-and-default':    Logs the error at first and then returns operation
  #                       neutral value, which should look like there is no
  #                       cache in use.
  #
  # 'custom':             User provides his own binding to implementation of `RecoveryPolicy`
  #
  #
  # Besides logging and re-populating the exceptions, it is also possible to
  # send email or re-run the failed command, which could like like certain robustness.
  #
  # note: this is global definition, can be locally overriden for each
  # cache instance. To do so, redefine this property
  # under 'play.cache.redis.instance.instance-name.this-property'.
  #
  recovery: log-and-default
}

# ==================
# Akka configuration
# ==================
akka {
  log-dead-letters = off
  log-dead-letters-during-shutdown = off

  actor {
    serialization-bindings {
      "java.io.Serializable" = java
      "scala.collection.immutable.List" = java
    }
  }
}
